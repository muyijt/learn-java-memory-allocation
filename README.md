# learn-java-memory-allocation
> 学习java内存分配

## 对象创建主要流程
![对象创建主要流程](https://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/38637691/share/2026-2-9/1770647690/main.svg)

## 类加载检查
- 虚拟机遇到new指令，首先检查这个指令的参数是否能在常量池中定位到一个符号引用，并且检查这个符号引用代表类是否已被加载、解析和初始化过。如果没有，执行相应的类加载过程

## 分配内存
- 类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定

### 划分内存方法
- 指针碰撞（默认）
  - 如果java堆中内存是绝对规整，所有用过的内存都放在一边，空闲内存在另一边，中间放着一个指针作为分界点指示器，那分配内存就是把哪个指针向空闲空间那挪动与对象大小相等的距离
- 空闲列表
  - 如果java堆中内存并不是规整，已使用内存和空闲内存相互交错，那就没有办法简单地进行指针碰撞，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实力并更新列表上记录
- 并发情况下内存分配有问题（正在给A对象分配内存，指针还没修改，对象B又同时使用原来指针来分配内存），解决方法如下：
  - CAS+失败重试
  - 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）
    - 每个线程在java堆中预先分配一小块内存

## 初始化
- 内存分配完成后，虚拟机需要将分配到的内存空间都初始化零值

## 设置对象头
- Mark Word标记字段
- Klass Pointer类型指针
- 数组长度（只有数组对象才有）

### Mark Word标记字段说明
<table>
  <thead>
    <tr>
      <th rowspan="2">对象状态</th>
      <th colspan="2">25bit</th>
      <th rowspan="2">4bit</th>
      <th>1bit</th>
      <th>2bit</th>
    </tr>
    <tr>
      <th>23bit</th>
      <th>2bit</th>
      <th>是否偏向锁</th>
      <th>锁标志</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>无锁状态</td>
      <td colspan="2">对象的hashCode</td>
      <td>分代年龄</td>
      <td>0</td>
      <td>01</td>
    </tr>
    <tr>
      <td>轻量级锁</td>
      <td colspan="4">指向栈中锁记录的指针</td>
      <td>00</td>
    </tr>
    <tr>
      <td>重量级锁</td>
      <td colspan="4">指向互斥量(重量级锁)的指针</td>
      <td>10</td>
    </tr>
    <tr>
      <td>GC标记</td>
      <td colspan="4">空</td>
      <td>11</td>
    </tr>
    <tr>
      <td>偏向锁</td>
      <td>线程ID</td>
      <td>Epoch</td>
      <td>分代年龄</td>
      <td>1</td>
      <td>01</td>
    </tr>
  </tbody>
</table>

> 服务器内存不要超过32G，超过32G，指针压缩会失效，会占用较大带宽，同时GC也会承受较大压力

## 执行<init>方法
- 为对象属性赋程序员指定的值

---------------------------------------------------------------------------------------------

## 对象内存分配

### 对象分配到栈上

```
Java中对象是在堆中进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多会给GC带来较大压力，GC会触发STW，进而影响系统性能。
为了减少对象在堆内存中数量，JVM通过逃逸分析确定对象会不会被外部访问，如果不会被外部访问（不会逃逸）就可以将该对象在栈上分配，这样对象占用的内存空间
就会随着栈帧出栈而释放，减轻GC压力
```

- 对象逃逸分析
  - 分析对象动态作用域。当一个对象在方法中被定义后，如果被外部方法引用，那对象就逃逸，没被外部方法引用，就是没逃逸
- 标量替换
  - 通过逃逸分析确定对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解成若干个被这个方法使用的成员变量来替代
    - 标量: 不可被进一步分解的量，而Java的基本数据类型就是标量
    - 聚合量: 可以被进一步分解的量，在Java中对象是可以被进一步分解的聚合量

### 对象在Eden区域分配

- 大多数情况，对象在新生代中Eden区分配，当Eden区没有足够空间进行分配时会出发一次Minor GC
- Minor GC: 发生在新生代的垃圾收集动作
- Major GC: 一般会回收老年代、年轻代、方法区的垃圾，慢
- Eden与Survivor区默认为8:1:1
- -XX:+UseAdaptiveSizePolicy（默认开启）会让eden与survivor比自动变化
- -XX:-UseAdaptiveSizePolicy eden与survivor比固定不变

### 大对象直接进入老年代

- -XX:PretenureSizeThreshold可以设置大对象的大小（这个参数只在Serial和ParNew两个收集器下有效）

### 长期存活对象进入老年代

- 经过一次GC，对象仍然存货，对象年龄+1，年龄达到阈值后，进入老年代
- XX:MaxTenuringThreshold可以这只年龄阈值（默认15岁，CMS收集器默认6岁）

### 对象动态年龄判断

- 经过GC后，eden区与from survivor区中所有存活对象，年龄1+年龄2+……+年龄n对象总和超过了to survivor区的50%，此时年龄>=n的对象放入老年代
- -XX:TargetSurvivorRatio可以指定比例（默认50%）

### 老年代空间担保机制

- 老年代剩余空间按是否大于历史每次minor gc后进入老年代的对象的平均大小，如果大于触发minor gc，否则触发full gc

## 对象内存回收

- 引用计数法
  - 给对象添加引用计数器，每当有一个地方引用它，计数器加1，引用失效，计数器减1，计数器为0对象就不再被使用。（循环引用的问题）
- 可达性分析算法
  - 将GC Roots对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余都是垃圾对象。
  - GC Roots对象: 线程栈中变量，静态变量