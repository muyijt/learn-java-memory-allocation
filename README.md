# learn-java-memory-allocation
> 学习java内存分配

## 对象创建主要流程
![对象创建主要流程](https://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/38637691/share/2026-2-9/1770647690/main.svg)

## 类加载检查
- 虚拟机遇到new指令，首先检查这个指令的参数是否能在常量池中定位到一个符号引用，并且检查这个符号引用代表类是否已被加载、解析和初始化过。如果没有，执行相应的类加载过程

## 分配内存
- 类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定

### 划分内存方法
- 指针碰撞（默认）
  - 如果java堆中内存是绝对规整，所有用过的内存都放在一边，空闲内存在另一边，中间放着一个指针作为分界点指示器，那分配内存就是把哪个指针向空闲空间那挪动与对象大小相等的距离
- 空闲列表
  - 如果java堆中内存并不是规整，已使用内存和空闲内存相互交错，那就没有办法简单地进行指针碰撞，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实力并更新列表上记录
- 并发情况下内存分配有问题（正在给A对象分配内存，指针还没修改，对象B又同时使用原来指针来分配内存），解决方法如下：
  - CAS+失败重试
  - 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）
    - 每个线程在java堆中预先分配一小块内存

## 初始化
- 内存分配完成后，虚拟机需要将分配到的内存空间都初始化零值

## 设置对象头
- Mark Word标记字段
- Klass Pointer类型指针
- 数组长度（只有数组对象才有）

### Mark Word标记字段说明
<table>
  <thead>
    <tr>
      <th rowspan="2">对象状态</th>
      <th colspan="2">25bit</th>
      <th rowspan="2">4bit</th>
      <th>1bit</th>
      <th>2bit</th>
    </tr>
    <tr>
      <th>23bit</th>
      <th>2bit</th>
      <th>是否偏向锁</th>
      <th>锁标志</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>无锁状态</td>
      <td colspan="2">对象的hashCode</td>
      <td>分代年龄</td>
      <td>0</td>
      <td>01</td>
    </tr>
    <tr>
      <td>轻量级锁</td>
      <td colspan="4">指向栈中锁记录的指针</td>
      <td>00</td>
    </tr>
    <tr>
      <td>重量级锁</td>
      <td colspan="4">指向互斥量(重量级锁)的指针</td>
      <td>10</td>
    </tr>
    <tr>
      <td>GC标记</td>
      <td colspan="4">空</td>
      <td>11</td>
    </tr>
    <tr>
      <td>偏向锁</td>
      <td>线程ID</td>
      <td>Epoch</td>
      <td>分代年龄</td>
      <td>1</td>
      <td>01</td>
    </tr>
  </tbody>
</table>

> 服务器内存不要超过32G，超过32G，指针压缩会失效，会占用较大带宽，同时GC也会承受较大压力

## 执行<init>方法
- 为对象属性赋程序员指定的值

---------------------------------------------------------------------------------------------

## 对象内存分配

### 对象分配到栈上

```
Java中对象是在堆中进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多会给GC带来较大压力，GC会触发STW，进而影响系统性能。
为了减少对象在堆内存中数量，JVM通过逃逸分析确定对象会不会被外部访问，如果不会被外部访问（不会逃逸）就可以将该对象在栈上分配，这样对象占用的内存空间
就会随着栈帧出栈而释放，减轻GC压力
```

- 对象逃逸分析
  - 分析对象动态作用域。当一个对象在方法中被定义后，如果被外部方法引用，那对象就逃逸，没被外部方法引用，就是没逃逸
- 标量替换
  - 通过逃逸分析确定对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解成若干个被这个方法使用的成员变量来替代
    - 标量: 不可被进一步分解的量，而Java的基本数据类型就是标量
    - 聚合量: 可以被进一步分解的量，在Java中对象是可以被进一步分解的聚合量

### 对象在Eden区域分配